import { t as throwInternalError, J as JspmError, r as relativeUrl, a as resolver, i as isURL, n as newPackageTarget, l as log, b as importedFrom, c as baseUrl, d as isPlain, p as parsePkg } from './resolver-45c5386a.js';
import sver from 'sver';
import { builtinModules } from 'module';
import { pathToFileURL, fileURLToPath } from 'url';
import { readFileSync, writeFileSync } from 'fs';
import os from 'os';
import path from 'path';
import 'process';
import 'crypto';
import 'es-module-lexer';
import 'mkdirp';
import 'buffer';
import 'sver/convert-range';

var toml = {};

function setResolution(resolutions, name, pkgUrl, resolution) {
    if (!pkgUrl.endsWith('/'))
        throwInternalError();
    resolutions[pkgUrl] = resolutions[pkgUrl] || {};
    resolutions[pkgUrl][name] = resolution;
}
function pruneResolutions(resolutions, to) {
    const newResolutions = {};
    for (const [name, parent] of to) {
        const resolution = resolutions[parent][name];
        newResolutions[parent] = newResolutions[parent] || {};
        newResolutions[parent][name] = resolution;
    }
    return newResolutions;
}
function loadVersionLock(lockFile) {
    let exists = false;
    const resolutions = {};
    const lockUrl = pathToFileURL(lockFile);
    function parseResolutionURL(url, name) {
        try {
            return new URL(url + (url[url.length - 1] === '/' || url.indexOf('|') !== -1 ? '' : '/'), lockUrl).href;
        }
        catch {
            throw new JspmError(`Invalid package URL ${url} ${name ? `for ${name} ` : ''}in lockfile ${lockFile}`, 'ERR_INVALID_LOCKFILE');
        }
    }
    function parseResolutions(deps, resolutions) {
        const pkgResolutions = Object.create(null);
        for (const impt of Object.keys(deps)) {
            const resolution = deps[impt];
            if (typeof resolution !== 'string')
                continue;
            const url = parseResolutionURL(resolution, impt);
            resolutions[url] = resolutions[url] || Object.create(null);
            pkgResolutions[impt] = url;
        }
        return pkgResolutions;
    }
    let source;
    try {
        source = readFileSync(lockFile);
        exists = true;
    }
    catch { }
    const { package: packages } = source ? toml.parse(source.toString()) : { package: null };
    if (!Array.isArray(packages))
        return { resolutions, exists };
    for (const { url, deps } of packages) {
        const scopeURL = parseResolutionURL(url);
        if (typeof deps === 'object')
            resolutions[scopeURL] = parseResolutions(deps, resolutions);
        else if (scopeURL.endsWith('/'))
            resolutions[scopeURL] = Object.create(null);
    }
    return { resolutions, exists };
}
function saveVersionLock(resolutions, lockFile) {
    const lockFileUrl = new URL('./', pathToFileURL(lockFile));
    const packages = [];
    for (const pkgUrl of Object.keys(resolutions)) {
        const url = relativeUrl(new URL(pkgUrl), lockFileUrl).slice(0, -1);
        const entries = Object.entries(resolutions[pkgUrl]);
        if (entries.length === 0)
            continue;
        packages.push(entries.length ? {
            url,
            deps: Object.fromEntries(entries.map(([key, value]) => {
                const target = relativeUrl(new URL(value), lockFileUrl);
                return [key, target.endsWith('/') ? target.slice(0, -1) : target];
            }).sort(([a], [b]) => a.localeCompare(b)))
        } : { url });
    }
    packages.sort(({ url: a }, { url: b }) => a.localeCompare(b));
    let original;
    try {
        original = readFileSync(lockFile).toString();
    }
    catch { }
    const output = '# Generated by jspm\n' + toml.stringify({ package: packages }).split('\n').map((line) => line.trimLeft()).join('\n');
    if (output !== original) {
        writeFileSync(lockFile, output);
        return true;
    }
    return false;
}

// @ts-ignore
const defaultStyle = {
    tab: '  ',
    newline: os.EOL,
    trailingNewline: os.EOL,
    indent: '',
    quote: '"'
};
function detectNewline(source) {
    let newLineMatch = source.match(/\r?\n|\r(?!\n)/);
    if (newLineMatch)
        return newLineMatch[0];
    return os.EOL;
}
function detectIndent(source, newline) {
    let indent = undefined;
    // best-effort tab detection
    // yes this is overkill, but it avoids possibly annoying edge cases
    let lines = source.split(newline);
    for (const line of lines) {
        const curIndent = line.match(/^\s*[^\s]/);
        if (curIndent && (indent === undefined || curIndent.length < indent.length))
            indent = curIndent[0].slice(0, -1);
    }
    lines = lines.map(line => line.slice(indent.length));
    let tabSpaces = lines.map(line => line.match(/^[ \t]*/)?.[0] || '') || [];
    let tabDifferenceFreqs = new Map();
    let lastLength = 0;
    tabSpaces.forEach(tabSpace => {
        let diff = Math.abs(tabSpace.length - lastLength);
        if (diff !== 0)
            tabDifferenceFreqs.set(diff, (tabDifferenceFreqs.get(diff) || 0) + 1);
        lastLength = tabSpace.length;
    });
    let bestTabLength = 0;
    for (const tabLength of tabDifferenceFreqs.keys()) {
        if (!bestTabLength || tabDifferenceFreqs.get(tabLength) >= tabDifferenceFreqs.get(bestTabLength))
            bestTabLength = tabLength;
    }
    // having determined the most common spacing difference length,
    // generate samples of this tab length from the end of each line space
    // the most common sample is then the tab string
    let tabSamples = new Map();
    tabSpaces.forEach(tabSpace => {
        let sample = tabSpace.substr(tabSpace.length - bestTabLength);
        tabSamples.set(sample, (tabSamples.get(sample) || 0) + 1);
    });
    let bestTabSample = '';
    for (const [sample, freq] of tabSamples) {
        if (!bestTabSample || freq > tabSamples.get(bestTabSample))
            bestTabSample = sample;
    }
    if (lines.length < 5 && lines.reduce((cnt, line) => cnt + line.length, 0) < 100)
        bestTabSample = '  ';
    return { indent: indent || '', tab: bestTabSample };
}
function detectStyle(source) {
    let style = Object.assign({}, defaultStyle);
    style.newline = detectNewline(source);
    let { indent, tab } = detectIndent(source, style.newline);
    style.indent = indent;
    style.tab = tab;
    let quoteMatch = source.match(/"|'/);
    if (quoteMatch)
        style.quote = quoteMatch[0];
    style.trailingNewline = source && source.match(new RegExp(style.newline + '$')) ? style.newline : '';
    return style;
}

function parseStyled(source, fileName) {
    // remove any byte order mark
    if (source.startsWith('\uFEFF'))
        source = source.substr(1);
    let style = detectStyle(source);
    try {
        return { json: JSON.parse(source), style };
    }
    catch (e) {
        throw new JspmError(`Error parsing JSON file${fileName ? ' ' + fileName : ''}`);
    }
}
function stringifyStyled(json, style) {
    let jsonString = JSON.stringify(json, null, style.tab);
    return style.indent + jsonString
        .replace(/([^\\])""/g, '$1' + style.quote + style.quote) // empty strings
        .replace(/([^\\])"/g, '$1' + style.quote)
        .replace(/\n/g, style.newline + style.indent) + (style.trailingNewline || '');
}

async function updatePjson(pjsonBase, updateFn) {
    const pjsonUrl = new URL('package.json', pjsonBase);
    let input;
    try {
        input = readFileSync(pjsonUrl).toString();
    }
    catch (e) {
        input = '{}\n';
    }
    let { json: pjson, style } = parseStyled(input);
    pjson = await updateFn(pjson) || pjson;
    const output = stringifyStyled(pjson, style);
    if (output === input)
        return false;
    writeFileSync(pjsonUrl, stringifyStyled(pjson, style));
    resolver.pcfgs[pjsonBase] = pjson;
    return true;
}

// @ts-ignore
const { Semver } = sver;
const builtinSet = new Set(builtinModules);
class Installer {
    constructor(baseUrl, opts) {
        this.installing = false;
        this.newInstalls = false;
        this.currentInstall = Promise.resolve();
        // @ts-ignore
        this.stdlibTarget = new URL('../../core/dist', import.meta.url);
        this.added = new Map();
        this.hasLock = false;
        this.installBaseUrl = baseUrl.href;
        this.opts = opts;
        this.lockfilePath = fileURLToPath(this.installBaseUrl + 'jspm.lock');
        const { resolutions, exists: hasLock } = loadVersionLock(this.lockfilePath);
        this.hasLock = hasLock;
        this.installs = resolutions;
        if (opts.stdlib) {
            if (isURL(opts.stdlib) || opts.stdlib[0] === '.') {
                this.stdlibTarget = new URL(opts.stdlib, baseUrl);
                if (this.stdlibTarget.href.endsWith('/'))
                    this.stdlibTarget.pathname = this.stdlibTarget.pathname.slice(0, -1);
            }
            else {
                this.stdlibTarget = newPackageTarget(opts.stdlib, this.installBaseUrl);
            }
        }
    }
    async startInstall() {
        if (this.installing)
            return this.currentInstall.then(() => this.startInstall());
        let finishInstall;
        this.installing = true;
        this.newInstalls = false;
        this.added = new Map();
        this.currentInstall = new Promise(resolve => {
            finishInstall = async (success) => {
                if (!success) {
                    this.installing = false;
                    resolve();
                    return false;
                }
                const save = this.opts.save || this.opts.saveDev || this.opts.savePeer || this.opts.saveOptional || this.hasLock || this.opts.lock;
                // update the package.json dependencies
                let pjsonChanged = false;
                const saveField = this.opts.saveDev ? 'devDependencies' : this.opts.savePeer ? 'peerDependencies' : this.opts.saveOptional ? 'optionalDependencies' : 'dependencies';
                if (saveField && save) {
                    pjsonChanged = await updatePjson(this.installBaseUrl, async (pjson) => {
                        pjson[saveField] = pjson[saveField] || {};
                        for (const [name, target] of this.added) {
                            if (target instanceof URL) {
                                if (target.protocol === 'file:') {
                                    pjson[saveField][name] = 'file:' + path.relative(fileURLToPath(this.installBaseUrl), fileURLToPath(target));
                                }
                                else {
                                    pjson[saveField][name] = target.href;
                                }
                            }
                            else {
                                let versionRange = target.ranges.map(range => range.toString()).join(' || ');
                                if (versionRange === '*') {
                                    const pcfg = await resolver.getPackageConfig(this.installs[this.installBaseUrl][target.name]);
                                    if (pcfg)
                                        versionRange = '^' + pcfg?.version;
                                }
                                pjson[saveField][name] = (target.name === name ? '' : target.registry + ':' + target.name + '@') + versionRange;
                            }
                        }
                    });
                }
                // prune the lockfile to the include traces only
                // this is done after pjson updates to include any adds
                if (this.opts.prune || pjsonChanged) {
                    const deps = await resolver.getDepList(this.installBaseUrl, true);
                    // existing deps is any existing builtin resolutions
                    const existingBuiltins = new Set(Object.keys(this.installs[this.installBaseUrl] || {}).filter(name => builtinSet.has(name)));
                    await this.lockInstall([...new Set([...deps, ...existingBuiltins])], this.installBaseUrl, true);
                }
                const lockChanged = this.hasLock || this.opts.lock ? saveVersionLock(this.installs, this.lockfilePath) : false;
                this.installing = false;
                resolve();
                return pjsonChanged || lockChanged;
            };
        });
        return finishInstall;
    }
    async lockInstall(installs, pkgUrl = this.installBaseUrl, prune = true) {
        const visited = new Set();
        const visitInstall = async (name, pkgUrl) => {
            if (visited.has(name + '##' + pkgUrl))
                return;
            visited.add(name + '##' + pkgUrl);
            const installUrl = await this.install(name, pkgUrl);
            const installPkgUrl = installUrl.split('|')[0] + (installUrl.indexOf('|') === -1 ? '' : '/');
            const deps = await resolver.getDepList(installPkgUrl);
            const existingDeps = Object.keys(this.installs[installPkgUrl] || {});
            await Promise.all([...new Set([...deps, ...existingDeps])].map(dep => visitInstall(dep, installPkgUrl)));
        };
        await Promise.all(installs.map(install => visitInstall(install, pkgUrl)));
        if (prune) {
            const pruneList = [...visited].map(item => {
                const [name, pkgUrl] = item.split('##');
                return [name, pkgUrl];
            });
            this.installs = pruneResolutions(this.installs, pruneList);
        }
    }
    replace(target, replacePkgUrl) {
        let targetUrl;
        if (target instanceof URL) {
            targetUrl = target.href;
        }
        else {
            const pkg = this.getBestMatch(target);
            if (!pkg) {
                if (this.installs[replacePkgUrl])
                    return false;
                throw new Error('No installation found to replace.');
            }
            targetUrl = resolver.pkgToUrl(pkg);
        }
        let replaced = false;
        for (const pkgUrl of Object.keys(this.installs)) {
            for (const name of Object.keys(this.installs[pkgUrl])) {
                if (this.installs[pkgUrl][name] === targetUrl) {
                    this.installs[pkgUrl][name] = replacePkgUrl;
                    replaced = true;
                }
            }
            if (pkgUrl === targetUrl) {
                this.installs[replacePkgUrl] = this.installs[pkgUrl];
                delete this.installs[pkgUrl];
                replaced = true;
            }
        }
        return replaced;
    }
    async installTarget(pkgName, target, pkgScope, pjsonPersist, parentUrl = pkgScope) {
        if (this.opts.freeze)
            throw new JspmError(`"${pkgName}" is not installed in the jspm lockfile, imported from ${parentUrl}.`, 'ERR_NOT_INSTALLED');
        this.newInstalls = true;
        if (pjsonPersist) {
            if (pkgScope === this.installBaseUrl && pkgScope.startsWith('file:')) {
                this.added.set(pkgName, target);
            }
            else {
                log('info', `Package ${pkgName} not declared in package.json dependencies${importedFrom(parentUrl)}.`);
            }
        }
        if (target instanceof URL) {
            log('install', `${pkgName} ${pkgScope} -> ${target.href}`);
            const pkgUrl = target.href + (target.href.endsWith('/') ? '' : '/');
            setResolution(this.installs, pkgName, pkgScope, pkgUrl);
            return pkgUrl;
        }
        if (this.opts.freeze) {
            const existingInstall = this.getBestMatch(target);
            if (existingInstall) {
                log('install', `${pkgName} ${pkgScope} -> ${existingInstall.registry}:${existingInstall.name}@${existingInstall.version}`);
                const pkgUrl = resolver.pkgToUrl(existingInstall);
                setResolution(this.installs, pkgName, pkgScope, pkgUrl);
                return pkgUrl;
            }
        }
        const latest = await resolver.resolveLatestTarget(target, false, parentUrl);
        const installed = await this.getInstalledPackages(target);
        const restrictedToPkg = await this.tryUpgradePackagesTo(latest, installed);
        // cannot upgrade to latest -> stick with existing resolution (if compatible)
        if (restrictedToPkg && !this.opts.latest) {
            log('install', `${pkgName} ${pkgScope} -> ${restrictedToPkg.registry}:${restrictedToPkg.name}@${restrictedToPkg.version}`);
            const pkgUrl = resolver.pkgToUrl(restrictedToPkg);
            setResolution(this.installs, pkgName, pkgScope, pkgUrl);
            return pkgUrl;
        }
        log('install', `${pkgName} ${pkgScope} -> ${latest.registry}:${latest.name}@${latest.version}`);
        const pkgUrl = resolver.pkgToUrl(latest);
        setResolution(this.installs, pkgName, pkgScope, pkgUrl);
        return pkgUrl;
    }
    async install(pkgName, pkgUrl, parentUrl = this.installBaseUrl) {
        if (!this.installing)
            throwInternalError();
        if (!this.opts.reset) {
            const existingUrl = this.installs[pkgUrl]?.[pkgName];
            if (existingUrl && !this.opts.reset)
                return existingUrl;
        }
        const pcfg = await resolver.getPackageConfig(pkgUrl) || {};
        // package dependencies
        const installTarget = pcfg.dependencies?.[pkgName] || pcfg.peerDependencies?.[pkgName] || pcfg.optionalDependencies?.[pkgName] || pcfg.devDependencies?.[pkgName];
        if (installTarget) {
            const target = newPackageTarget(installTarget, pkgUrl, pkgName);
            return this.installTarget(pkgName, target, pkgUrl, false, parentUrl);
        }
        // node.js core
        if (builtinSet.has(pkgName)) {
            const target = this.stdlibTarget;
            const resolution = (await this.installTarget(pkgName, target, pkgUrl, false, parentUrl)).slice(0, -1) + '|nodelibs/' + pkgName;
            setResolution(this.installs, pkgName, pkgUrl, resolution);
            return resolution;
        }
        // global install fallback
        const target = newPackageTarget('*', pkgUrl, pkgName);
        const exactInstall = await this.installTarget(pkgName, target, pkgUrl, true, parentUrl);
        return exactInstall;
    }
    async getInstalledPackages(_pkg) {
        // TODO: to finish up version deduping algorithm, we need this
        // operation to search for all existing installs in this.installs
        // that have a target matching the given package
        // This is done by checking their package.json and seeing if the package.json target range
        // contains this target range
        return [];
    }
    getBestMatch(matchPkg) {
        let bestMatch = null;
        for (const pkgUrl of Object.keys(this.installs)) {
            const pkg = resolver.parseUrlPkg(pkgUrl);
            if (pkg && this.inRange(pkg, matchPkg)) {
                if (bestMatch)
                    bestMatch = Semver.compare(new Semver(bestMatch.version), pkg.version) === -1 ? pkg : bestMatch;
                else
                    bestMatch = pkg;
            }
        }
        return bestMatch;
    }
    inRange(pkg, target) {
        return pkg.registry === target.registry && pkg.name === target.name && target.ranges.some(range => range.has(pkg.version, true));
    }
    // upgrade any existing packages to this package if possible
    tryUpgradePackagesTo(pkg, installed) {
        if (this.opts.freeze)
            return;
        const pkgVersion = new Semver(pkg.version);
        let hasUpgrade = false;
        for (const version of new Set(installed.map(({ pkg }) => pkg.version))) {
            let hasVersionUpgrade = true;
            for (const { pkg, target } of installed) {
                if (pkg.version !== version)
                    continue;
                // user out-of-version lock
                if (!this.opts.reset && !target.ranges.some(range => range.has(pkg.version, true))) {
                    hasVersionUpgrade = false;
                    continue;
                }
                if (pkgVersion.lt(pkg.version) || !target.ranges.some(range => range.has(pkgVersion, true))) {
                    hasVersionUpgrade = false;
                    continue;
                }
            }
            if (hasVersionUpgrade)
                hasUpgrade = true;
            if (hasUpgrade || this.opts.latest) {
                for (const { pkg, install } of installed) {
                    if (pkg.version !== version)
                        continue;
                    setResolution(this.installs, install.name, install.pkgUrl, resolver.pkgToUrl(pkg));
                }
            }
        }
    }
}

function alphabetize(obj) {
    const out = {};
    for (const key of Object.keys(obj).sort())
        out[key] = obj[key];
    return out;
}

class ImportMap {
    constructor(mapBaseUrl) {
        this.imports = Object.create(null);
        this.scopes = Object.create(null);
        this.integrity = Object.create(null);
        this.depcache = Object.create(null);
        this.baseUrl = baseUrl;
        this.mapStyle = defaultStyle;
        if (mapBaseUrl)
            this.baseUrl = mapBaseUrl;
    }
    clone() {
        const cloned = new ImportMap(this.baseUrl);
        cloned.extend(this);
        return cloned;
    }
    extend(map, overrideScopes = false) {
        const baseUrl = this.baseUrl.href;
        if (map.baseUrl && baseUrl !== map.baseUrl.href)
            this.rebase(map.baseUrl.href);
        Object.assign(this.imports, map.imports);
        if (overrideScopes) {
            Object.assign(this.scopes, map.scopes);
        }
        else if (map.scopes) {
            for (const scope of Object.keys(map.scopes))
                Object.assign(this.scopes[scope] = this.scopes[scope] || Object.create(null), map.scopes[scope]);
        }
        Object.assign(this.integrity, map.integrity);
        Object.assign(this.depcache, map.depcache);
        if (baseUrl !== this.baseUrl.href)
            this.rebase(baseUrl);
        return this;
    }
    sort() {
        this.imports = alphabetize(this.imports);
        this.scopes = alphabetize(this.scopes);
        this.depcache = alphabetize(this.depcache);
        this.integrity = alphabetize(this.integrity);
        for (const scope of Object.keys(this.scopes))
            this.scopes[scope] = alphabetize(this.scopes[scope]);
    }
    clearIntegrity() {
        this.integrity = Object.create(null);
    }
    clearDepcache() {
        this.depcache = Object.create(null);
    }
    setIntegrity(url, integrity) {
        this.integrity[url] = integrity;
    }
    addMapping(name, targetUrl, parent) {
        if (!parent) {
            this.imports[name] = targetUrl;
        }
        else {
            if (!parent.endsWith('/'))
                throwInternalError();
            this.scopes[parent] = this.scopes[parent] || {};
            this.scopes[parent][name] = targetUrl;
        }
    }
    replace(pkgUrl, newPkgUrl) {
        const newRelPkgUrl = relativeUrl(newPkgUrl, this.baseUrl);
        for (const impt of Object.keys(this.imports)) {
            const target = this.imports[impt];
            if (target !== null && target.startsWith(pkgUrl))
                this.imports[impt] = newRelPkgUrl + target.slice(pkgUrl.length);
        }
        for (const scope of Object.keys(this.scopes)) {
            const scopeImports = this.scopes[scope];
            const scopeUrl = new URL(scope, this.baseUrl).href;
            if (scopeUrl.startsWith(pkgUrl)) {
                const newScope = newRelPkgUrl + scopeUrl.slice(pkgUrl.length);
                delete this.scopes[scope];
                this.scopes[newScope] = scopeImports;
            }
            for (const name of Object.keys(scopeImports)) {
                const target = scopeImports[name];
                if (target !== null && target.startsWith(pkgUrl))
                    scopeImports[name] = newRelPkgUrl + target.slice(pkgUrl.length);
            }
        }
        return this;
    }
    // TODO: flattening operation that combines subpaths where possible into folder maps
    combineSubpaths() {
    }
    flatten() {
        for (const scope of Object.keys(this.scopes)) {
            const scopeUrl = new URL(scope, this.baseUrl);
            let scopeBase, scopeBaseUrl;
            if (scopeUrl.protocol !== 'file:') {
                if (scopeUrl.origin === this.baseUrl.origin && scopeUrl.href.startsWith(this.baseUrl.origin))
                    scopeBaseUrl = '/';
                else if (scopeUrl.href.startsWith(scopeUrl.origin))
                    scopeBaseUrl = scopeUrl.origin + '/';
                if (scopeBaseUrl)
                    scopeBase = this.scopes[scopeBaseUrl] || {};
            }
            if (!scopeBase)
                continue;
            const scopeImports = this.scopes[scope];
            let flattenedAll = true;
            for (const name of Object.keys(scopeImports)) {
                const existing = scopeBase[name];
                const target = scopeImports[name];
                if (target === null)
                    continue;
                const targetUrl = new URL(target, this.baseUrl);
                if (this.imports[name] === targetUrl.href) {
                    delete scopeImports[name];
                }
                else if (!existing || new URL(existing, this.baseUrl).href === targetUrl.href) {
                    scopeBase[name] = relativeUrl(targetUrl, this.baseUrl);
                    delete scopeImports[name];
                    this.scopes[scopeBaseUrl] = alphabetize(scopeBase);
                }
                else {
                    flattenedAll = false;
                }
            }
            if (flattenedAll)
                delete this.scopes[scope];
        }
        for (const dep of Object.keys(this.depcache)) {
            if (this.depcache[dep].length === 0)
                delete this.depcache[dep];
        }
        return this;
    }
    rebase(newBaseUrl = this.baseUrl.href) {
        const oldBaseUrl = this.baseUrl;
        this.baseUrl = new URL(newBaseUrl, baseUrl);
        if (!this.baseUrl.pathname.endsWith('/'))
            this.baseUrl.pathname += '/';
        // unnormalized targets starting with / are ignored
        for (const impt of Object.keys(this.imports)) {
            const target = this.imports[impt];
            if (target !== null && target[0] !== '/')
                this.imports[impt] = relativeUrl(new URL(target, oldBaseUrl), this.baseUrl);
        }
        for (const scope of Object.keys(this.scopes)) {
            const newScope = relativeUrl(new URL(scope, oldBaseUrl), this.baseUrl);
            const scopeImports = this.scopes[scope];
            if (scope !== newScope) {
                delete this.scopes[scope];
                this.scopes[newScope] = scopeImports;
            }
            for (const name of Object.keys(scopeImports)) {
                const target = scopeImports[name];
                if (target !== null && target[0] !== '/')
                    scopeImports[name] = relativeUrl(new URL(target, oldBaseUrl), this.baseUrl);
            }
        }
        const newDepcache = Object.create(null);
        for (const dep of Object.keys(this.depcache)) {
            const importsRebased = this.depcache[dep].map(specifier => {
                if (isPlain(specifier))
                    return specifier;
                return relativeUrl(new URL(specifier, oldBaseUrl), this.baseUrl);
            });
            const depRebased = relativeUrl(new URL(dep, oldBaseUrl), this.baseUrl);
            newDepcache[depRebased] = importsRebased;
        }
        this.depcache = newDepcache;
        const newIntegrity = Object.create(null);
        for (const dep of Object.keys(this.integrity)) {
            const integrityVal = this.integrity[dep];
            const depRebased = relativeUrl(new URL(dep, oldBaseUrl), this.baseUrl);
            newIntegrity[depRebased] = integrityVal;
        }
        this.integrity = newIntegrity;
        return this;
    }
    resolve(specifier, parentUrl) {
        if (!isPlain(specifier))
            return new URL(specifier, parentUrl);
        const scopeMatches = getScopeMatches(parentUrl, this.scopes, this.baseUrl);
        for (const [scope] of scopeMatches) {
            const mapMatch = getMapMatch(specifier, this.scopes[scope]);
            if (mapMatch) {
                const target = this.scopes[scope][mapMatch];
                if (target === null)
                    return null;
                return new URL(target + specifier.slice(mapMatch.length), this.baseUrl);
            }
        }
        const mapMatch = getMapMatch(specifier, this.imports);
        if (mapMatch) {
            const target = this.imports[mapMatch];
            if (target === null)
                return null;
            return new URL(target + specifier.slice(mapMatch.length), this.baseUrl);
        }
        throw new JspmError(`Unable to resolve "${specifier}" from ${parentUrl.href}`, 'MODULE_NOT_FOUND');
    }
    toJSON() {
        const obj = {};
        if (Object.keys(this.imports).length)
            obj.imports = this.imports;
        if (Object.keys(this.scopes).length)
            obj.scopes = this.scopes;
        if (Object.keys(this.integrity).length)
            obj.integrity = this.integrity;
        if (Object.keys(this.depcache).length)
            obj.depcache = this.depcache;
        return obj;
    }
    toString(minify) {
        const obj = this.toJSON();
        return stringifyStyled(obj, minify ? Object.assign(this.mapStyle, { indent: '', tab: '', newline: '' }) : this.mapStyle);
    }
}
const scopeCache = new WeakMap();
function getScopeMatches(parentUrl, scopes, baseUrl) {
    const parentUrlHref = parentUrl.href;
    let scopeCandidates = scopeCache.get(scopes);
    if (!scopeCandidates) {
        scopeCandidates = Object.keys(scopes).map(scope => [scope, new URL(scope, baseUrl).href]);
        scopeCandidates = scopeCandidates.sort(([, matchA], [, matchB]) => matchA.length < matchB.length ? 1 : -1);
        scopeCache.set(scopes, scopeCandidates);
    }
    return scopeCandidates.filter(([, scopeUrl]) => {
        return scopeUrl === parentUrlHref || scopeUrl.endsWith('/') && parentUrlHref.startsWith(scopeUrl);
    });
}
function getMapMatch(specifier, map) {
    if (specifier in map)
        return specifier;
    let curMatch;
    for (const match of Object.keys(map)) {
        const wildcard = match.endsWith('*');
        if (!match.endsWith('/') && !wildcard)
            continue;
        if (specifier.startsWith(wildcard ? match.slice(0, -1) : match)) {
            if (!curMatch || match.length > curMatch.length)
                curMatch = match;
        }
    }
    return curMatch;
}

// The tracemap fully drives the installer
class TraceMap {
    constructor(mapBase, opts = {}) {
        this.env = ['browser', 'development'];
        this.tracedUrls = {};
        this.traces = new Set();
        this.staticList = new Set();
        this.dynamicList = new Set();
        this.mapBase = mapBase;
        this.opts = opts;
        if (this.opts.env)
            this.env = this.opts.env;
        if (opts.inputMap)
            this.map = opts.inputMap instanceof ImportMap ? opts.inputMap : new ImportMap(mapBase).extend(opts.inputMap);
        else
            this.map = new ImportMap(mapBase);
    }
    replace(target, pkgUrl) {
        return this.installer.replace(target, pkgUrl);
    }
    async visit(url, visitor, seen = new Set()) {
        if (seen.has(url))
            return;
        seen.add(url);
        const entry = this.tracedUrls[url];
        if (!entry)
            return;
        for (const dep of Object.keys(entry.deps)) {
            await this.visit(entry.deps[dep], visitor, seen);
        }
        await visitor(url, entry);
    }
    getPreloads(integrity, baseUrl) {
        return [...this.staticList].map(url => {
            const relUrl = relativeUrl(new URL(url), baseUrl);
            return {
                url: relUrl.startsWith('./') ? relUrl.slice(2) : relUrl,
                integrity: integrity ? this.tracedUrls[url].integrity : false,
                jspm: !url.startsWith('https://ga.jspm.io/') && !url.startsWith('https://system.ga.jspm.io/')
            };
        });
    }
    checkTypes() {
        let system = false, esm = false;
        for (const url of [...this.staticList, ...this.dynamicList]) {
            const trace = this.tracedUrls[url];
            if (trace.system)
                system = true;
            else
                esm = true;
        }
        return { system, esm };
    }
    async startInstall() {
        this.pjsonBase = this.pjsonBase || new URL((await resolver.getPackageBase(this.mapBase.href)) || baseUrl.href);
        if (!this.installer) {
            if (!this.pjsonBase)
                log('warn', 'No project package.json found, create a package.json file to define install resolution targets for updating or publishing.');
            this.installer = new Installer(this.pjsonBase || baseUrl, this.opts);
        }
        const finishInstall = await this.installer.startInstall();
        return async (success) => {
            if (!success) {
                finishInstall(false);
                return false;
            }
            // re-drive all the traces to convergence
            if (!this.opts.fullMap) {
                const traceResolutions = {};
                do {
                    this.installer.newInstalls = false;
                    await Promise.all([...this.traces].map(async (trace) => {
                        const [specifier, parentUrl] = trace.split('##');
                        const resolved = await this.trace(specifier, new URL(parentUrl));
                        traceResolutions[trace] = resolved;
                    }));
                } while (this.installer.newInstalls);
                // now second-pass visit the trace to gather the exact graph and collect the import map
                let list = this.staticList;
                const discoveredDynamics = new Set();
                const depVisitor = async (url, entry) => {
                    list.add(url);
                    const parentPkgUrl = await resolver.getPackageBase(url);
                    for (const dep of Object.keys(entry.dynamicDeps)) {
                        const resolvedUrl = entry.dynamicDeps[dep][0];
                        if (isPlain(dep))
                            this.map.addMapping(dep, resolvedUrl, parentPkgUrl);
                        discoveredDynamics.add(resolvedUrl);
                    }
                    for (const dep of Object.keys(entry.deps)) {
                        if (isPlain(dep))
                            this.map.addMapping(dep, entry.deps[dep], parentPkgUrl);
                    }
                };
                const seen = new Set();
                for (const trace of this.traces) {
                    const url = traceResolutions[trace];
                    const [specifier, parentUrl] = trace.split('##');
                    if (isPlain(specifier) && parentUrl === this.mapBase.href)
                        this.map.addMapping(specifier, url);
                    await this.visit(url, depVisitor, seen);
                }
                list = this.dynamicList;
                for (const url of discoveredDynamics) {
                    await this.visit(url, depVisitor, seen);
                }
            }
            return finishInstall(true);
        };
    }
    async add(name, target, persist = true) {
        const installed = await this.installer.installTarget(name, target, this.mapBase.href, persist);
        return installed.slice(0, -1);
    }
    async addAllPkgMappings(name, pkgUrl, env, parentPkgUrl) {
        const [url, subpathFilter] = pkgUrl.split('|');
        const exports = await resolver.resolveExports(url + (url.endsWith('/') ? '' : '/'), env, subpathFilter);
        for (const key of Object.keys(exports)) {
            if (key.endsWith('!cjs'))
                continue;
            if (!exports[key])
                continue;
            if (key.endsWith('*'))
                continue;
            this.map.addMapping(name + key.slice(1), new URL(exports[key], url).href, parentPkgUrl);
        }
    }
    async trace(specifier, parentUrl = this.mapBase, env = ['import', ...this.env]) {
        const parentPkgUrl = await resolver.getPackageBase(parentUrl.href);
        if (!parentPkgUrl)
            throwInternalError();
        this.traces.add(specifier + '##' + parentUrl.href);
        if (!isPlain(specifier)) {
            const resolvedUrl = new URL(specifier, parentUrl);
            if (resolvedUrl.protocol !== 'file:' && resolvedUrl.protocol !== 'https:' && resolvedUrl.protocol !== 'http:' && resolvedUrl.protocol !== 'node:' && resolvedUrl.protocol !== 'data:')
                throw new JspmError(`Found unexpected protocol ${resolvedUrl.protocol}${importedFrom(parentUrl)}`);
            log('trace', `${specifier} ${parentUrl.href} -> ${resolvedUrl}`);
            await this.traceUrl(resolvedUrl.href, parentUrl, env);
            return resolvedUrl.href;
        }
        const parsed = parsePkg(specifier);
        if (!parsed)
            throw new JspmError(`Invalid package name ${specifier}`);
        const { pkgName, subpath } = parsed;
        // Subscope override
        const scopeMatches = getScopeMatches(parentUrl, this.map.scopes, this.map.baseUrl);
        const pkgSubscopes = scopeMatches.filter(([, url]) => url.startsWith(parentPkgUrl));
        if (pkgSubscopes.length) {
            for (const [scope] of pkgSubscopes) {
                const mapMatch = getMapMatch(specifier, this.map.scopes[scope]);
                if (mapMatch) {
                    const resolved = new URL(this.map.scopes[scope][mapMatch] + specifier.slice(mapMatch.length), this.map.baseUrl).href;
                    log('trace', `${specifier} ${parentUrl.href} -> ${resolved}`);
                    await this.traceUrl(resolved, parentUrl, env);
                    return resolved;
                }
            }
        }
        // Scope override
        const userScopeMatch = scopeMatches.find(([, url]) => url === parentPkgUrl);
        if (userScopeMatch) {
            const imports = this.map.scopes[userScopeMatch[0]];
            const userImportsMatch = getMapMatch(specifier, imports);
            const userImportsResolved = userImportsMatch ? new URL(imports[userImportsMatch] + specifier.slice(userImportsMatch.length), this.map.baseUrl).href : null;
            if (userImportsResolved) {
                log('trace', `${specifier} ${parentUrl.href} -> ${userImportsResolved}`);
                await this.traceUrl(userImportsResolved, parentUrl, env);
                return userImportsResolved;
            }
        }
        // Own name import
        const pcfg = await resolver.getPackageConfig(parentPkgUrl) || {};
        if (pcfg.exports && pcfg.name === pkgName) {
            const exports = await resolver.resolveExports(parentPkgUrl, env);
            const match = getMapMatch(subpath, exports);
            if (!match)
                throw new JspmError(`No '${subpath}' exports subpath defined in ${parentPkgUrl} resolving ${pkgName}${importedFrom(parentUrl)}.`);
            if (match) {
                const resolved = new URL(exports[match] + subpath.slice(match.length), parentPkgUrl).href;
                log('trace', `${specifier} ${parentUrl.href} -> ${resolved}`);
                await this.traceUrl(resolved, parentUrl, env);
                return resolved;
            }
        }
        // @ts-ignore
        const installed = this.opts.freeze ? this.installer?.installs[parentPkgUrl]?.[pkgName] : await this.installer?.install(pkgName, parentPkgUrl, parentUrl.href);
        if (installed) {
            let [pkgUrl, subpathFilter] = installed.split('|');
            if (subpathFilter)
                pkgUrl += '/';
            const exports = await resolver.resolveExports(pkgUrl, env, subpathFilter);
            const match = getMapMatch(subpath, exports);
            if (!match)
                throw new JspmError(`No '${subpath}' exports subpath defined in ${pkgUrl} resolving ${pkgName}${importedFrom(parentUrl)}.`);
            if (match) {
                const resolved = new URL(exports[match] + subpath.slice(match.length), pkgUrl).href;
                log('trace', `${specifier} ${parentUrl.href} -> ${resolved}`);
                await this.traceUrl(resolved, parentUrl, env);
                return resolved;
            }
        }
        // User import overrides
        const userImportsMatch = getMapMatch(specifier, this.map.imports);
        const userImportsResolved = userImportsMatch ? new URL(this.map.imports[userImportsMatch] + specifier.slice(userImportsMatch.length), this.map.baseUrl).href : null;
        if (userImportsResolved) {
            log('trace', `${specifier} ${parentUrl.href} -> ${userImportsResolved}`);
            await this.traceUrl(userImportsResolved, parentUrl, env);
            return userImportsResolved;
        }
        throw new JspmError(`No resolution in map for ${specifier}${importedFrom(parentUrl)}`);
    }
    async traceUrl(resolvedUrl, parentUrl, env) {
        const wasCJS = await resolver.wasCommonJS(resolvedUrl);
        if (wasCJS && env.includes('import'))
            env = env.map(e => e === 'import' ? 'require' : e);
        else if (!wasCJS && env.includes('require'))
            env = env.map(e => e === 'require' ? 'import' : e);
        if (resolvedUrl in this.tracedUrls)
            return;
        if (resolvedUrl.endsWith('/'))
            throw new JspmError(`Trailing "/" installs not yet supported installing ${resolvedUrl} for ${parentUrl.href}`);
        const traceEntry = this.tracedUrls[resolvedUrl] = {
            wasCJS,
            deps: Object.create(null),
            dynamicDeps: Object.create(null),
            hasStaticParent: true,
            size: NaN,
            integrity: '',
            system: false,
            babel: false
        };
        const { deps, dynamicDeps, integrity, size, system } = await resolver.analyze(resolvedUrl, parentUrl, this.opts.system);
        traceEntry.integrity = integrity;
        traceEntry.system = !!system;
        traceEntry.size = size;
        let allDeps = deps;
        if (dynamicDeps.length && !this.opts.static) {
            allDeps = [...deps];
            for (const dep of dynamicDeps) {
                if (!allDeps.includes(dep))
                    allDeps.push(dep);
            }
        }
        const resolvedUrlObj = new URL(resolvedUrl);
        await Promise.all(allDeps.map(async (dep) => {
            const resolvedUrl = await this.trace(dep, resolvedUrlObj, env);
            if (deps.includes(dep))
                traceEntry.deps[dep] = resolvedUrl;
            if (dynamicDeps.includes(dep))
                traceEntry.dynamicDeps[dep] = [resolvedUrl];
        }));
    }
}

export default TraceMap;
